const fs = require('fs').promises;
const sysPath = require('path');
const nodegit = require('nodegit');
const fileType = require('./utils/file-type.js');

// from libgit2/include/git2/errors.h
const nodegitErrors = {
  '-1': 'GIT_ERROR', // Generic error
  '-3': 'no-such-path', // was 'GIT_ENOTFOUND', // Requested object could not be found
  '-4': 'GIT_EEXISTS', // Object exists preventing operation
  '-5': 'GIT_EAMBIGUOUS', // More than one object matches
  '-6': 'GIT_EBUFS', // Output buffer too short to hold data
  /*
   * GIT_EUSER is a special error that is never generated by libgit2
   * code.  You can return it from a callback (e.g to stop an iteration)
   * to know that it was generated by the callback and not by libgit2.
   */
  '-7': 'GIT_EUSER',

  '-8': 'GIT_EBAREREPO', // Operation not allowed on bare repository
  '-9': 'GIT_EUNBORNBRANCH', // HEAD refers to branch with no commits
  '-10': 'GIT_EUNMERGED', // Merge in progress prevented operation
  '-11': 'GIT_ENONFASTFORWARD', // Reference was not fast-forwardable
  '-12': 'GIT_EINVALIDSPEC', // Name/ref spec was not in a valid format
  '-13': 'GIT_ECONFLICT', // Checkout conflicts prevented operation
  '-14': 'GIT_ELOCKED', // Lock file prevented operation
  '-15': 'GIT_EMODIFIED', // Reference value does not match expected
  '-16': 'GIT_EAUTH', // Authentication error
  '-17': 'GIT_ECERTIFICATE', // Server certificate is invalid
  '-18': 'GIT_EAPPLIED', // Patch/merge has already been applied
  '-19': 'GIT_EPEEL', // The requested peel operation is not possible
  '-20': 'GIT_EEOF', // Unexpected EOF
  '-21': 'GIT_EINVALID', // Invalid operation or input
  '-22': 'GIT_EUNCOMMITTED', // Uncommitted changes in index prevented operation
  '-23': 'GIT_EDIRECTORY', // The operation is not valid for a directory
  '-24': 'GIT_EMERGECONFLICT', // A merge conflict exists and cannot continue

  '-30': 'GIT_PASSTHROUGH', // A user-configured callback refused to act
  '-31': 'GIT_ITEROVER', // Signals end of iteration with iterator
  '-32': 'GIT_RETRY', // Internal only
  '-33': 'GIT_EMISMATCH', // Hashsum mismatch in object
  '-34': 'GIT_EINDEXDIRTY', // Unsaved changes in the index would be overwritten
  '-35': 'GIT_EAPPLYFAIL', // Patch application failed
};
const normalizeError = (err) => {
  // console.error('normalizing', err);
  if (!err.errorCode && err.errno) err.errorCode = nodegitErrors[err.errno];
  throw err;
};

class UserError extends Error {
  constructor(code, message) {
    super(message || code);
    this.errorCode = code;
  }
}

const splitMail = (signature) => {
  if (!signature) return [];
  const match = /^([^<]*)<?([^>]*)>?$/.exec(signature);
  return match ? [match[1].trim(), match[2].trim()] : [];
};

/**
 * @param {nodegit.Commit} c
 * @param {nodegit.Oid}    [hId]
 */
const formatCommit = (c, hId) => {
  const [authorName, authorEmail] = splitMail(c.author().toString());
  const [committerName, committerEmail] = splitMail(c.author().toString());
  /** @type {Commit} */
  const out = {
    sha1: c.sha(),
    parents: c.parents().map(String),
    refs: hId && hId.equal(c.id()) ? ['HEAD'] : [], // TODO cached refs on client, don't include here
    message: c.message(),
    // TODO find out how to extract from rawHeader()
    authorDate: c.date().toJSON(),
    commitDate: c.date().toJSON(),
    authorName,
    authorEmail,
    committerName,
    committerEmail,
  };
  return out;
};

class NGWrap {
  constructor(ngRepo) {
    /** @type {nodegit.Repository} */
    this.r = ngRepo;
    // TODO use nodecache for expiration
    this._diffCache = {};
  }

  async addStash(message) {
    /** @type {Hash} */
    const oid = await nodegit.Stash.save(
      this.r,
      await this.r.defaultSignature(),
      message,
      nodegit.Stash.FLAGS.INCLUDE_UNTRACKED
    ).catch((err) => {
      // no changes
      if (err.errno === -3) return null;
      normalizeError(err);
    });
    return oid;
  }

  async deleteStash(index) {
    return nodegit.Stash.drop(this.r, index).catch(normalizeError);
  }

  async applyStash(index) {
    return nodegit.Stash.apply(this.r, index).catch(normalizeError);
  }

  async popStash(oid) {
    if (!oid) return;
    let index;
    await nodegit.Stash.foreach(this.r, (i, _msg, stashOid) => {
      if (stashOid.equal(oid)) index = i;
    }).catch(normalizeError);
    if (index != null) {
      await nodegit.Stash.pop(this.r, index, {
        flags: nodegit.Stash.APPLY_FLAGS.APPLY_REINSTATE_INDEX,
      }).catch(normalizeError);
    }
  }

  async getTags() {
    return nodegit.Tag.list(this.r).catch(normalizeError);
  }

  async deleteTag(name) {
    return nodegit.Tag.delete(this.r, name).catch(normalizeError);
  }

  async getRemotes() {
    return nodegit.Remote.list(this.r).catch(normalizeError);
  }

  async addRemote(name, url) {
    return nodegit.Remote.create(this.r, name, url).catch(normalizeError);
  }

  async deleteRemote(name) {
    return nodegit.Remote.delete(this.r, name).catch(normalizeError);
  }

  async getStashes() {
    const oids = [];
    await nodegit.Stash.foreach(this.r, (index, message, oid) => {
      oids.push(oid);
    }).catch(normalizeError);
    const stashes = await Promise.all(
      oids.map((oid) => this.r.getCommit(oid).catch(normalizeError))
    );
    /** @type {Commit[]} */
    return Promise.all(
      stashes.map(async (stash, index) => ({
        ...(await this.getDiff({ commit: stash })),
        ...formatCommit(stash),
        reflogId: `${index}`,
        reflogName: `stash@{${index}}`,
      }))
    );
  }

  rootPath() {
    return this.r.isBare() ? this.r.path().slice(0, -1) : this.r.workdir().slice(0, -1);
  }

  async status() {
    const { r } = this;
    const branch = await r.getCurrentBranch();
    const index = await r.index();
    const inCherry = r.isCherrypicking();
    const inMerge = r.isMerging();
    const inRebase = r.isRebasing();
    const inConflict = index.hasConflicts();
    /** @type {Record<string, FileStatus>} */
    const files = {};
    for (const f of await r.getStatusExt()) {
      const fileName = f.path();
      let oldFileName;
      if (!f.isNew()) {
        const diff = f.indexToWorkdir() || f.headToIndex();
        oldFileName = diff.oldFile().path();
      } else {
        oldFileName = fileName;
      }
      const displayName = f.isRenamed() ? `${oldFileName} → ${fileName}` : fileName;
      files[fileName] = {
        fileName,
        oldFileName,
        displayName,
        staged: f.inIndex(),
        removed: f.isDeleted(),
        isNew: f.isNew(),
        conflict: f.isConflicted(),
        renamed: f.isRenamed(),
        type: fileType(fileName),
      };
    }

    /** @type {GitStatus} */
    return {
      branch: branch && branch.shorthand(),
      inCherry,
      inMerge,
      inRebase,
      inConflict,
      files,
    };
  }

  // TODO accept SHAs to walk
  async log(limit = 500, skip) {
    const walker = this.r.createRevWalk();
    walker.sorting(nodegit.Revwalk.SORT.TIME);
    const head = await this.r.getHeadCommit().catch(normalizeError);
    if (head) walker.push(head.id());
    walker.pushGlob('*');
    if (skip) await walker.fastWalk(skip).catch(normalizeError);
    const commits = await walker.getCommits(limit).catch(normalizeError);
    // TODO detect head client-side
    const headId = head && head.id();
    // TODO only keep formatCommit, the stats are for a details call
    /** @type {Commit[]} */
    const result = await Promise.all(
      commits.map(async (c) => ({ ...(await getFileStats(c)), ...formatCommit(c, headId) }))
    );
    return result;
  }

  async refs() {
    // TODO need to make this smart for many tags
    const refs = await this.r.getReferences().catch(normalizeError);
    /** @type {Ref[]} */
    const out = await Promise.all(
      refs.map(async (ref) => ({
        name: ref.name(),
        sha1: `${ref.isTag() ? (await ref.peel(1)).id() : ref.target()}`,
      }))
    );
    return out;
  }

  async getCurrentBranch() {
    const ref = await this.r.getCurrentBranch().catch(normalizeError);
    return ref.shorthand();
  }

  async getHead() {
    const head = await this.r.getHeadCommit().catch(normalizeError);
    return formatCommit(head, head.id());
  }

  /**
   * @param {string}    remoteName
   * @param {RefName[]} [refs]
   * @param {boolean}   [prune]
   */
  async remoteFetch(remoteName, refs = null, prune) {
    const remote = await this.r.getRemote(remoteName).catch(normalizeError);
    // TODO use credentialshelper
    await remote.fetch(
      refs,
      {
        callbacks: {
          credentials: (url, userName) => nodegit.Cred.sshKeyFromAgent(userName),
        },
        prune: prune ? nodegit.Fetch.PRUNE.GIT_FETCH_PRUNE : undefined,
      },
      undefined
    );
  }

  async remoteAllFetch() {
    const remotes = await this.getRemotes();
    // making calls serially as credential helpers may get confused to which cred to get.
    for (const name of remotes) {
      await this.remoteFetch(name);
    }
  }

  // TODO not sure if we should have this
  async remoteFetchTags(remoteName) {
    const remote = await this.r.getRemote(remoteName).catch(normalizeError);
    // TODO use credentialshelper
    await remote.connect(nodegit.Enums.DIRECTION.FETCH, {
      credentials: (url, userName) => nodegit.Cred.sshKeyFromAgent(userName),
    });
    const refs = await remote.referenceList();
    await remote.disconnect();
    /** @type {Ref[]} */
    const out = [];
    for (const t of refs) {
      const name = t.name();
      if (!name.startsWith('/refs/tags/')) continue;
      const sha1 = t.oid().toString();
      const ref = { name, sha1, remote: remoteName };
      if (name.endsWith('{}')) out[out.length - 1] = ref;
      else out.push(ref);
    }
    return out;
  }

  // TODO whitespace
  /**
   * @typedef {{
   *   diffKey?: string;
   *   commit?: nodegit.Commit;
   *   oid?: string | nodegit.Oid;
   *   oldOid?: string | nodegit.Oid;
   *   ignoreWhiteSpace?: boolean;
   * }} DiffArgs
   * @param {DiffArgs} args
   */
  async getDiff({ diffKey, commit, oid, oldOid }) {
    if (diffKey) {
      if (this._diffCache[diffKey]) return this._diffCache[diffKey];
      const s = diffKey.split('/');
      oid = s[0];
      oldOid = s[1];
      if (oldOid === 'null') oldOid = null;
    }
    let newTree, oldTree;
    const toIndex = oid === 'index';
    const toWorkTree = oid === 'worktree';
    if (toIndex || toWorkTree) {
      const head = await this.r.getHeadCommit();
      if (head) {
        oldTree = await head.getTree();
      }
      oldOid = `HEAD@${Date.now()}`;
    } else {
      if (oid) {
        commit = await this.r.getCommit(oid);
        if (!commit) throw new UserError('unknown-commit', `No commit ${oid}`);
      } else {
        oid = commit.id();
      }
      if (!commit) throw new UserError('no-commit-given', 'need commit or oid');

      newTree = await commit.getTree();

      if (!oldOid && oldOid !== null) {
        oldOid = (await commit.parents()[0]) || null;
      }
      if (oldOid) {
        const oC = await this.r.getCommit(oldOid);
        if (!oC) throw new UserError('unknown-commit', `No commit oldOid ${oid}`);
        oldTree = await oC.getTree();
      }
    }

    const diff = toIndex
      ? await nodegit.Diff.treeToIndex(this.r, oldTree)
      : toWorkTree
      ? await nodegit.Diff.treeToWorkdir(this.r, oldTree)
      : await nodegit.Diff.treeToTree(this.r, oldTree, newTree);
    // Find renames, compact diff
    await diff.findSimilar({ flags: nodegit.Diff.FIND.RENAMES });

    diffKey = `${oid}/${oldOid}`;
    this._diffCache[diffKey] = diff;

    return { diffKey, diff };
  }

  /**
   * Get changes between oldOid and oid.
   * You can pass the commit instead of oid.
   * If oldOid is `null`, the entire tree of oid is shown.
   * If oldOid is falsy, the commit's leftmost parent is assumed.
   */
  async getChanges(/** @type {DiffArgs} */ args) {
    const { diffKey, diff } = await this.getDiff(args);

    const stat = await diff.getStats();
    const additions = +stat.insertions();
    const deletions = +stat.deletions();

    const patches = await diff.patches();
    /** @type {DiffStat[]} */
    const fileLineDiffs = patches.map((p, idx) => {
      const fileName = p.isDeleted() ? p.oldFile().path() : p.newFile().path();
      const oldFileName = p.isAdded() ? fileName : p.oldFile().path();
      const displayName = p.isRenamed() ? `${oldFileName} → ${fileName}` : fileName;
      const { total_additions, total_deletions } = p.lineStats();

      return {
        idx,
        oldFileName, // TODO only when renamed or deleted
        fileName, // TODO not if deleted
        displayName, // TODO client-side
        additions: total_additions,
        deletions: total_deletions,
        type: fileType(fileName || oldFileName),
      };
    });
    return { additions, deletions, fileLineDiffs };
  }

  // TODO async getStashDiff() {}
  // TODO async getStagingDiff() {}

  // TODO limit and cursor{hunk,line}
  /** @param {{ diffKey: string; idx: number }} arg */
  async diffFile({ diffKey, idx }) {
    const diff = await this.getDiff({ diffKey });
    const patch = (await diff.patches())[idx];
    if (!patch) throw new UserError('invalid-diff', `Invalid idx ${idx} for diffKey ${diffKey}`);

    const text = [`diff --git a/${patch.oldFile().path()} b/${patch.newFile().path()}`];
    for (const hunk of await patch.hunks()) {
      const lines = await hunk.lines();
      text.push(
        hunk.header().trim(),
        ...lines.map((line) => `${String.fromCharCode(line.origin())}${line.content()}`)
      );
    }
    return text.join('\n');
  }
}

const repoPs = {};
/**
 * Memoize nodegit opened repos.
 *
 * @param {string} path  The path to the repository.
 * @returns {Promise<NGWrap>}
 */
const getRepo = async (path) => {
  if (!repoPs[path]) {
    repoPs[path] =
      /** @type {Promise<NGWrap>} */
      (
        nodegit.Repository.open(path)
          .then((repo) => new NGWrap(repo))
          .catch((err) => {
            repoPs[path] = null;
            normalizeError(err);
          })
      );
  }
  return repoPs[path];
};

/**
 * Clear memoized repo.
 *
 * @param {string} path  The path to the repository.
 */
const uncacheRepo = async (path) => {
  delete repoPs[path];
};

const quickStatus = async (path) => {
  try {
    const repo = await getRepo(path);
    return { gitRootPath: repo.rootPath(), type: repo.r.isBare() ? 'bare' : 'inited' };
  } catch (err) {
    if (err.errno !== -3) throw err;
    if (/failed to resolve/.test(err.message)) return { gitRootPath: path, type: 'no-such-path' };

    // for uninited directory, let's check if it's any immediate directories are
    // git repository so we can display them.
    const filePaths = (await fs.readdir(path))
      .filter((filePath) => !filePath.startsWith('.'))
      .map((filePath) => sysPath.join(path, filePath));
    const subRepos = [];
    await Promise.all(
      filePaths.map(async (subPath) => {
        const subRepo = await getRepo(subPath).catch(() => {});
        if (subRepo) subRepos.push(subPath);
      })
    );
    return { type: 'uninited', gitRootPath: path, subRepos };
  }
};

const initGit = (path, isBare) =>
  // nodegit requires a number https://github.com/nodegit/nodegit/issues/538
  nodegit.Repository.init(path, isBare ? 1 : 0).catch(normalizeError);

module.exports = {
  NGWrap,
  getRepo,
  uncacheRepo,
  initGit,
  quickStatus,
};
